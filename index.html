<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Árvore Kd (k-d tree)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .control-panel label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .control-panel input, .control-panel button, .control-panel textarea {
            transition: all 0.2s ease-in-out;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #visualization-container {
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Simulador Interativo de Árvore Kd</h1>
            <p class="mt-2 text-lg text-gray-600">Visualize como uma Árvore Kd particiona o espaço para buscas eficientes de vizinhos próximos.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8">

            <!-- Painel de Controle -->
            <div class="w-full lg:w-1/3 xl:w-1/4 bg-white p-6 rounded-xl shadow-lg control-panel">
                <h2 class="text-2xl font-semibold mb-6 border-b pb-3">Controles</h2>

                <div class="space-y-6">
                    <div>
                        <label for="num-points" class="text-gray-700">Pontos Aleatórios</label>
                        <input type="number" id="num-points" value="50" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <button id="add-points-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 shadow-md">Gerar Pontos Aleatórios</button>
                    <button id="reset-btn" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 shadow-md">Resetar Simulação</button>
                </div>

                <!-- Dados Personalizados -->
                <div class="mt-8 pt-6 border-t">
                    <h3 class="text-xl font-semibold mb-4">Dados Personalizados</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="custom-data" class="text-gray-700">Insira os dados (um por linha):</label>
                            <textarea id="custom-data" rows="7" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="&quot;casa&quot; → (15, 80)"></textarea>
                        </div>
                        <button id="load-custom-data-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-md">Carregar Dados e Construir</button>
                    </div>
                </div>

                <!-- Painel de Resultados -->
                <div id="results-panel" class="mt-8 pt-6 border-t">
                    <h3 class="text-xl font-semibold mb-4">Resultados da Busca</h3>
                    <div class="text-sm space-y-4 p-3 bg-gray-50 rounded-lg">
                        <p><strong>Status:</strong> <span id="status-text">Aguardando pontos...</span></p>
                        <p><strong>Nós Visitados (Kd-tree):</strong> <span id="nodes-visited">N/A</span></p>
                        <p><strong>Pontos Verificados (Bruto):</strong> <span id="brute-force-checks">N/A</span></p>
                        <p class="font-semibold text-blue-700"><strong>Ganho de Eficiência:</strong> <span id="efficiency-gain">N/A</span></p>
                    </div>
                </div>
            </div>

            <!-- Área de Visualização -->
            <div class="w-full lg:w-2/3 xl:w-3/4 bg-white p-4 rounded-xl shadow-lg">
                <div id="visualization-container" class="w-full h-full min-h-[400px] md:min-h-[600px]"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Configurações Iniciais ---
            const visContainer = document.getElementById('visualization-container');
            const width = visContainer.clientWidth;
            const height = visContainer.clientHeight > 400 ? visContainer.clientHeight : 600;
            const K_DIM = 2; // Trabalhando em 2 dimensões (x, y)

            const svg = d3.select("#visualization-container").append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("border", "1px solid #e2e8f0")
                .style("border-radius", "0.75rem");

            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip");

            let dataPoints = [];
            let kdTree = null;

            // --- Elementos da UI ---
            const numPointsInput = document.getElementById('num-points');
            const addPointsBtn = document.getElementById('add-points-btn');
            const resetBtn = document.getElementById('reset-btn');
            const customDataInput = document.getElementById('custom-data');
            const loadCustomDataBtn = document.getElementById('load-custom-data-btn');
            
            const statusText = document.getElementById('status-text');
            const nodesVisitedText = document.getElementById('nodes-visited');
            const bruteForceChecksText = document.getElementById('brute-force-checks');
            const efficiencyGainText = document.getElementById('efficiency-gain');

            // --- Lógica da Árvore Kd ---
            class Node {
                constructor(data, axis, left = null, right = null) {
                    this.data = data; // { label: string, point: [x, y] }
                    this.axis = axis;
                    this.left = left;
                    this.right = right;
                }
            }

            function buildKdTree(points, depth = 0) {
                if (points.length === 0) return null;
                const axis = depth % K_DIM;
                points.sort((a, b) => a.point[axis] - b.point[axis]);
                const medianIndex = Math.floor(points.length / 2);
                
                return new Node(
                    points[medianIndex],
                    axis,
                    buildKdTree(points.slice(0, medianIndex), depth + 1),
                    buildKdTree(points.slice(medianIndex + 1), depth + 1)
                );
            }

            // --- Lógica da Busca ---
            let nodesVisitedCount = 0;

            function findNearestNeighbor(node, target, depth = 0) {
                if (node === null) {
                    return { data: null, distance: Infinity };
                }
                
                nodesVisitedCount++;
                const axis = depth % K_DIM;
                
                let nextBranch = (target[axis] < node.data.point[axis]) ? node.left : node.right;
                let oppositeBranch = (target[axis] < node.data.point[axis]) ? node.right : node.left;

                let best = findNearestNeighbor(nextBranch, target, depth + 1);
                
                const currentDist = euclideanDistance(target, node.data.point);
                if (currentDist < best.distance) {
                    best = { data: node.data, distance: currentDist };
                }

                const distToPlane = Math.abs(target[axis] - node.data.point[axis]);
                if (distToPlane < best.distance) {
                    const oppositeBest = findNearestNeighbor(oppositeBranch, target, depth + 1);
                    if (oppositeBest.distance < best.distance) {
                        best = oppositeBest;
                    }
                }
                
                return best;
            }
            
            function euclideanDistance(p1, p2) {
                return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
            }

            // --- Lógica da Visualização ---
            function drawScene() {
                svg.selectAll("*").remove();

                if (kdTree) {
                    drawTreePartitions(kdTree, 0, 0, width, height);
                }

                const g = svg.append("g");

                // Desenha os pontos
                g.selectAll("circle.data-point")
                    .data(dataPoints)
                    .enter()
                    .append("circle")
                    .attr("class", "data-point")
                    .attr("cx", d => d.point[0])
                    .attr("cy", d => d.point[1])
                    .attr("r", 5)
                    .attr("fill", "#4A5568")
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1);
                        tooltip.html(`<strong>${d.label}</strong><br>(${d.point[0].toFixed(0)}, ${d.point[1].toFixed(0)})`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => tooltip.style("opacity", 0));

                // Desenha os rótulos
                g.selectAll("text.label")
                    .data(dataPoints)
                    .enter()
                    .append("text")
                    .attr("class", "label")
                    .attr("x", d => d.point[0] + 8)
                    .attr("y", d => d.point[1] + 4)
                    .text(d => d.label)
                    .attr("font-size", "11px")
                    .attr("fill", "#2D3748");
            }

            function drawTreePartitions(node, x_min, y_min, x_max, y_max) {
                if (node === null) return;

                const axis = node.axis;
                const point = node.data.point;
                const line = svg.append("line").style("stroke", "#63B3ED").style("stroke-width", 1).style("stroke-dasharray", "4");

                if (axis === 0) { // Divisão vertical
                    line.attr("x1", point[0]).attr("y1", y_min).attr("x2", point[0]).attr("y2", y_max);
                    drawTreePartitions(node.left, x_min, y_min, point[0], y_max);
                    drawTreePartitions(node.right, point[0], y_min, x_max, y_max);
                } else { // Divisão horizontal
                    line.attr("x1", x_min).attr("y1", point[1]).attr("x2", x_max).attr("y2", point[1]);
                    drawTreePartitions(node.left, x_min, y_min, x_max, point[1]);
                    drawTreePartitions(node.right, x_min, point[1], x_max, y_max);
                }
            }
            
            function highlightSearch(query, nearestData) {
                svg.selectAll("circle.query-point, circle.nearest-neighbor").remove();

                svg.append("circle").attr("class", "query-point")
                    .attr("cx", query[0]).attr("cy", query[1])
                    .attr("r", 8).attr("fill", "none")
                    .attr("stroke", "#38A169").attr("stroke-width", 3);

                if (nearestData && nearestData.point) {
                    svg.append("circle").attr("class", "nearest-neighbor")
                        .attr("cx", nearestData.point[0]).attr("cy", nearestData.point[1])
                        .attr("r", 8).attr("fill", "none")
                        .attr("stroke", "#E53E3E").attr("stroke-width", 3);
                }
            }
            
            function parseCustomData(text) {
                const points = [];
                const lines = text.trim().split('\n');
                const regex = /"([^"]+)"\s*→\s*\(\s*(\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)\s*\)/;

                for (const line of lines) {
                    const match = line.match(regex);
                    if (match) {
                        points.push({
                            label: match[1],
                            point: [parseFloat(match[2]), parseFloat(match[4])]
                        });
                    }
                }
                return points;
            }

            // --- Manipuladores de Eventos ---
            function buildAndDraw(points) {
                if (points.length === 0) {
                    statusText.textContent = "Nenhum ponto para construir a árvore.";
                    return;
                }
                dataPoints = points;
                kdTree = buildKdTree(dataPoints.slice());
                drawScene();
                statusText.textContent = "Árvore construída. Clique na área para consultar.";
                bruteForceChecksText.textContent = dataPoints.length;
                nodesVisitedText.textContent = 'N/A';
                efficiencyGainText.textContent = 'N/A';
            }

            addPointsBtn.addEventListener('click', () => {
                const num = parseInt(numPointsInput.value, 10);
                const randomPoints = [];
                for (let i = 0; i < num; i++) {
                    randomPoints.push({
                        label: `P${i+1}`,
                        point: [
                            Math.random() * (width - 40) + 20,
                            Math.random() * (height - 40) + 20
                        ]
                    });
                }
                buildAndDraw(randomPoints);
            });
            
            loadCustomDataBtn.addEventListener('click', () => {
                const customPoints = parseCustomData(customDataInput.value);
                if (customPoints.length > 0) {
                    buildAndDraw(customPoints);
                } else {
                    statusText.textContent = "Dados inválidos. Verifique o formato.";
                }
            });

            resetBtn.addEventListener('click', () => {
                dataPoints = [];
                kdTree = null;
                svg.selectAll("*").remove();
                statusText.textContent = "Aguardando pontos...";
                nodesVisitedText.textContent = 'N/A';
                bruteForceChecksText.textContent = 'N/A';
                efficiencyGainText.textContent = 'N/A';
                customDataInput.value = '';
            });

            svg.on('click', (event) => {
                if (!kdTree) {
                    statusText.textContent = "Construa a árvore primeiro!";
                    return;
                }
                
                const queryPoint = d3.pointer(event);
                statusText.textContent = "Executando busca...";
                
                setTimeout(() => {
                    nodesVisitedCount = 0;
                    const nearestResult = findNearestNeighbor(kdTree, queryPoint);
                    
                    drawScene();
                    highlightSearch(queryPoint, nearestResult.data);

                    nodesVisitedText.textContent = nodesVisitedCount;
                    const gain = (dataPoints.length > 0) ? (1 - (nodesVisitedCount / dataPoints.length)) * 100 : 0;
                    efficiencyGainText.textContent = `${gain.toFixed(1)}%`;
                    statusText.textContent = "Busca concluída.";
                }, 100);
            });

            // --- Inicialização ---
            function initializeWithSampleData() {
                const sampleData = [
                    '"casa" → (150, 80)',
                    '"caso" → (200, 170)',
                    '"caos" → (250, 265)',
                    '"data" → (400, 300)',
                    '"gato" → (350, 150)'
                ].join('\n');
                customDataInput.value = sampleData;
                loadCustomDataBtn.click();
            }

            initializeWithSampleData();
        });
    </script>
</body>
</html>
